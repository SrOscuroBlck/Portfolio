<script lang="ts">
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  let scene: THREE.Scene;
  let camera: THREE.PerspectiveCamera;
  let renderer: THREE.WebGLRenderer;
  let controls: OrbitControls;
  let globeRadius = 20;
  let dots: THREE.Mesh[] = [];

  const init = () => {
    const container = document.querySelector(".globe-container") as HTMLElement;
    const canvas = document.querySelector(".globe-canvas") as HTMLCanvasElement;

    const sizes = {
      width: container.offsetWidth,
      height: container.offsetHeight,
    };

    scene = new THREE.Scene();

    camera = new THREE.PerspectiveCamera(
      30,
      sizes.width / sizes.height,
      0.1,
      1000
    );
    camera.position.z = 100;

    renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      alpha: true,
      antialias: true,
    });
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

    const pointLight = new THREE.PointLight(0xffffff, 1.5, 200);
    pointLight.position.set(-50, 0, 60);
    scene.add(pointLight);

    const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.6);
    scene.add(hemisphereLight);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.2;
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.enablePan = false;
    controls.enableZoom = false;

    controls.minPolarAngle = Math.PI / 2;
    controls.maxPolarAngle = Math.PI / 2;

    loadDotsTexture("/world_alpha_mini.jpg");
    animate();
  };

  const loadDotsTexture = (imageSrc: string) => {
    const image = new Image();
    image.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      if (ctx) {
        canvas.width = image.width;
        canvas.height = image.height;
        ctx.drawImage(image, 0, 0);
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        generateDotsFromTexture(imageData);
      }
    };
    image.src = imageSrc;
  };

  const generateDotsFromTexture = (imageData: ImageData) => {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const dotGeometry = new THREE.SphereGeometry(0.1, 8, 8);

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = (y * width + x) * 4;
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        if (r < 80 && g < 80 && b < 80) {
          const lat = (1 - y / height) * Math.PI - Math.PI / 2;
          const lon = (x / width) * 2 * Math.PI - Math.PI;

          const xPos = globeRadius * Math.cos(lat) * Math.cos(lon);
          const yPos = globeRadius * Math.sin(lat);
          const zPos = globeRadius * Math.cos(lat) * Math.sin(lon);

          const dotMaterial = new THREE.MeshBasicMaterial({
            color: 0xdedede,
            transparent: true,
            opacity: 1.0,
            depthTest: true,
            depthWrite: true,
          });

          const dot = new THREE.Mesh(dotGeometry, dotMaterial);
          dot.position.set(xPos, yPos, zPos);
          scene.add(dot);
          dots.push(dot);
        }
      }
    }
  };

  const toggleVisibilityOfBackDots = () => {
    dots.forEach((dot) => {
      const dotWorldPosition = new THREE.Vector3();
      dot.getWorldPosition(dotWorldPosition);
      const direction = dotWorldPosition.clone().sub(camera.position).normalize();
      const dotDirection = dot.position.clone().normalize();

      const dotFacingFactor = dotDirection.dot(direction);

      const newOpacity = THREE.MathUtils.lerp(0.2, 1.0, (dotFacingFactor + 1) / 2);
      dot.material.opacity = newOpacity;
    });
  };

  const animate = () => {
    controls.update();
    toggleVisibilityOfBackDots();
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  };

  window.onload = init;
</script>
