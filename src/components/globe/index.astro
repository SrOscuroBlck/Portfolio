<script>
  import * as THREE from "three";
  import { OrbitControls } from "three/addons/controls/OrbitControls.js";

  let scene, camera, renderer, controls;
  let globeRadius = 20;
  let dots = [];

  const init = () => {
    const container = document.querySelector(".globe-container");
    const canvas = document.querySelector(".globe-canvas");

    const sizes = {
      width: container.offsetWidth,
      height: container.offsetHeight,
    };

    scene = new THREE.Scene();

    // Camera with adjusted near/far clipping planes
    camera = new THREE.PerspectiveCamera(
      30,
      sizes.width / sizes.height,
      0.1,  // Near plane to avoid clipping too close
      1000  // Far plane for distant objects
    );
    camera.position.z = 100;

    renderer = new THREE.WebGLRenderer({
      canvas: canvas,
      alpha: true,
      antialias: true,  // Enable antialias for smoother edges
    });
    renderer.setSize(sizes.width, sizes.height);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));  // High-DPI rendering

    // Point Light
    const pointLight = new THREE.PointLight(0xffffff, 1.5, 200);
    pointLight.position.set(-50, 0, 60);
    scene.add(pointLight);

    // Hemisphere Light
    const hemisphereLight = new THREE.HemisphereLight(0xffffbb, 0x080820, 0.6);
    scene.add(hemisphereLight);

    controls = new OrbitControls(camera, renderer.domElement);
    controls.autoRotate = true;
    controls.autoRotateSpeed = 1.2;
    controls.enableDamping = true; // Enable damping for smooth camera movements
    controls.dampingFactor = 0.1;  // Adjust damping strength
    controls.enablePan = false;
    controls.enableZoom = false;

    // Restrict the rotation to horizontal (lock vertical movement)
    controls.minPolarAngle = Math.PI / 2; // 90 degrees, no vertical movement
    controls.maxPolarAngle = Math.PI / 2; // 90 degrees, no vertical movement

    loadDotsTexture("/world_alpha_mini.jpg");
    animate();
  };

  const loadDotsTexture = (imageSrc) => {
    const image = new Image();
    image.onload = () => {
      const canvas = document.createElement("canvas");
      const ctx = canvas.getContext("2d");
      canvas.width = image.width;
      canvas.height = image.height;
      ctx.drawImage(image, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      generateDotsFromTexture(imageData);
    };
    image.src = imageSrc;
  };

  const generateDotsFromTexture = (imageData) => {
    const width = imageData.width;
    const height = imageData.height;
    const data = imageData.data;
    const dotGeometry = new THREE.SphereGeometry(0.1, 8, 8); // Use SphereGeometry

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const i = (y * width + x) * 4;
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];

        // Only render dots where it's dark enough (based on pixel brightness)
        if (r < 80 && g < 80 && b < 80) {
          const lat = (1 - y / height) * Math.PI - Math.PI / 2; // Invert the latitude
          const lon = (x / width) * 2 * Math.PI - Math.PI; // Longitude

          // Convert lat/lon to 3D coordinates
          const xPos = globeRadius * Math.cos(lat) * Math.cos(lon);
          const yPos = globeRadius * Math.sin(lat);
          const zPos = globeRadius * Math.cos(lat) * Math.sin(lon);

          const dotMaterial = new THREE.MeshBasicMaterial({
            color: 0xdedede,
            transparent: true,
            opacity: 1.0,
            depthTest: true,
            depthWrite: true,
          });

          const dot = new THREE.Mesh(dotGeometry, dotMaterial);
          dot.position.set(xPos, yPos, zPos);
          scene.add(dot);
          dots.push(dot);  // Store the dots so we can toggle their visibility
        }
      }
    }
  };

  const toggleVisibilityOfBackDots = () => {
    dots.forEach((dot) => {
      const dotWorldPosition = new THREE.Vector3();
      dot.getWorldPosition(dotWorldPosition);
      const direction = dotWorldPosition.clone().sub(camera.position).normalize();
      const dotDirection = dot.position.clone().normalize();

      // Calculate how much the dot is facing the camera
      const dotFacingFactor = dotDirection.dot(direction); // Range from -1 (back) to 1 (front)

      // Adjust opacity based on the facing factor, front-facing dots have opacity 1, back-facing dots closer to 0.2
      const newOpacity = THREE.MathUtils.lerp(0.2, 1.0, (dotFacingFactor + 1) / 2);
      
      dot.material.opacity = newOpacity;  // Adjust opacity for depth effect
    });
  };

  const animate = () => {
    controls.update();
    toggleVisibilityOfBackDots();  // Adjust visibility in every frame
    renderer.render(scene, camera);
    requestAnimationFrame(animate);
  };

  window.onload = init;
</script>

<div class="globe-container" style="width: 100%; height: 350px; position: relative;">
  <canvas class="globe-canvas" style="width: 100%; height: 100%;"></canvas>
</div>
